# 函数

函数就好像一个模板，函数体里面的变量可以通过参数来替换掉。

用 `=>` 里面创建一个函数。

```js
(x) => x * 2
```

+ 箭头左边的 '(x)' 是一个参数。
+ 箭头左边的 'x * 2' 是函数体。

函数可以用圆括弧去调用：

```js
((x) => x * 2)(10)
// 20
```

调用函数时， 我们把 `x` 设定为 `10`, 这叫做 “传参”。结果是把函数体所有的 `x` 都替换为 `10`。

也就是说上面的表达式会变成：

```js
10 * 2
```

同个参数可以出现多次：

```js
((x) => x * x)(10)
// 100
```

传参替换后的结果是:

```js
10 * 10
// 100
```

参数的名字是什么不重要，下面的结果都是一样的：

```js
((x) => x * x)(10)
((a) => a * a)(10)
((cat) => cat * cat)(10)
```

## 多个参数

函数可以有多个参数：

```js
((x,y,z) => x * y * z)(1, 2, 3)
// 6
```

调用函数时会按循序把相对应的值替换进去：

+ x -> 1
+ y -> 2
+ z -> 3

```js
1 * 2 * 3
```

当然，参数可以在函数体里出现多次:

```js
((x,y,z) => [x * y, y * z])(1, 2, 3)
// [2, 6]
```

## 给函数一个名字

我们可以把函数放在一个变量里面，看起来会舒服一点, 而且也方便重复利用：

```js
f = (x,y,z) => [x * y, y * z];
f(1, 2, 3);
// [2, 6]

f(4, 5, 6);
// [20, 30]
```

把 `f` 这个符号替换为它的值, 我们能看到 `f(1,2,3)` 和上面直接调用函数是一样的：

```js
((x,y,z) => [x * y, y * z])(1, 2, 3);
```

# 练习

```js
f = ???

f(10, 10)
// 20

f(42, 42)
// 84
```

---

```js
f = ???

f(10, 10)
// [10, 10]

f([42], [42])
// [ [42], [42] ]
```

---

函数可以放在数组里面:

```js
// 怎么调用下面这个函数获得 1？
[[[() => 1]]]
// 1
```

```js
// 怎么调用下面这个函数获得 11？
[[[(x) => x + 1]]]
// 1
```

---

```js
f = () => 1;
f2 = () => [f];
c = [f2]

// 怎么返回 1？
```

```js
f = (x) => x * x;
f2 = () => [f];
c = [f2]

// 怎么返回 64？
```

```js
f = (x) => x * x;
f2 = (i) => [f][i];
c = [f2]

// 怎么返回 64？
```

```js
f = (x) => x * x;
f2 = (i) => [f][i - 1];
c = [f2]

// 怎么返回 64？
```

---

函数可以返回函数。

```js
f = () => (() => 1);
// 怎么调用 f 返回 1？
```

```js
f = () => () => () => 1;
// 怎么调用 f 返回 1？
```

```js
f = (a) => (b) => (c) => a + b + c;
// 怎么调用 f 返回 1 + 2 + 3？
```

---

函数可以当做参数。

```js
apply = (f, x, y) => f(x, y);

// 怎么用 apply 获得 15
apply(???, 5, 10)
// 15

// 怎么用 apply 获得 50
apply(???, 5, 10)
// 50
```

